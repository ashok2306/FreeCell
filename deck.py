# Class deck is used to create the deck by using the Card class.
# Deck would consist of cascade, foundation and cells.

# Importing the class needed
import random
from card import Card
import copy


# Deck class has method to implement and setup cards in a deck using cascade, cell and foundation.
# Deck class can move the cards between the elements and also has a method to find if the game ended in a victory
class Deck:
    # To create the deck class the parameters required are start number, end number and the number of suits required
    def __init__(self, value_start, value_end, number_of_suits):
        # Initializing the cascade deck, foundation and cells
        self.cards_deck = []
        self.final_deck = [[] for i in range(8)]
        self.foundation = [[Card(0, 0)] for i in range(4)]
        self.cell = [Card(0, 0)] * 4

        self.number_of_suits = number_of_suits
        self.number_of_cards = (value_end - value_start) + 1

        # Card number for the deck is generated by creating list having values between the start and the end value
        card_number = list(range(value_start, value_end + 1))

        # A card can be a part of 4 suits. a list Suit is created to hold these 4 suits
        suits = ['H', 'D', 'C', 'S']

        # If the number of suits are more than 4 then extend the list with the number of items
        if number_of_suits > 4:
            suits.extend(range(5, number_of_suits + 1))

        # The suits list is shuffled to randomize the pick
        random.shuffle(suits)

        # From the suits the number of suits required for the deck are picked based on the input received to the class
        card_suits = suits[0:number_of_suits]

        # For each card number a Card object is generated for the number of suits needed for the deck
        # The cards_deck would hold the card face with it's symbol returned from Card object
        for number in card_number:
            for suit in card_suits:
                self.cards_deck.append(Card(number, suit))

        # The cards_deck is shuffled to have randomness in the list
        self.shuffle()

        # The cards_deck should be split randomly and added to the cascade of size 8
        self.split_list()

    # Method to split the cards_deck randomly into a list of size 8. The list final_deck would have 8 sublist
    # and each sublist would have a random number of cards from the cards_deck
    def split_list(self):
        # Looping until the length of the cards_deck is empty
        while len(self.cards_deck) != 0:
            # Looping exactly 8 times to fill the list of size 8
            for i in range(0, 8):
                # Generating a random number from 0 to 5 or length of the cards_deck whichver is minimum.
                rand = random.randint(0, min(5, len(self.cards_deck)))
                for j in range(0, rand):
                    if len(self.cards_deck) != 0:
                        self.final_deck[i].append(self.cards_deck.pop(random.randint(0, len(self.cards_deck) - 1)))
                    else:
                        break

    # Method to shuffle the cards_deck to randomize the cards
    def shuffle(self):
        random.shuffle(self.cards_deck)

    # Method to pick the card from one place and move it to another place. The method take from place, to place,
    # from position and to position as inputs.
    def addCard(self, fromPlace, toPlace, fromPos, toPos):
        if fromPlace == 'cascade':
            if toPlace == 'cascade':
                # Remove the last item from final_deck for that position and append it to the final_deck position
                self.final_deck[toPos].append(self.final_deck[fromPos].pop(len(self.final_deck[fromPos]) - 1))
            elif toPlace == 'cell':
                # Remove the last item from the final deck for that position and add it to the cell position
                self.cell[toPos] = self.final_deck[fromPos].pop(len(self.final_deck[fromPos]) - 1)
            elif toPlace == 'foundation':
                # If the length of the foundation at that position is 1 andthe value is 0, then the foundation is empty
                # Replace the first element. Else append to the foundation at position
                if len(self.foundation[toPos]) == 1 and self.foundation[toPos][0].get_face() == 0:
                    self.foundation[toPos][0] = self.final_deck[fromPos].pop(len(self.final_deck[fromPos]) - 1)
                else:
                    self.foundation[toPos].append(self.final_deck[fromPos].pop(len(self.final_deck[fromPos]) - 1))

        elif fromPlace == 'foundation':
            # If the length of the foundation is 1
            if len(self.foundation[fromPos]) == 1:
                # For cascade, remove the item from the foundation at position and append it to the cascade
                if toPlace == 'cascade':
                    self.final_deck[toPos].append(self.foundation[fromPos].pop(len(self.foundation[fromPos]) - 1))
                # For cell, remove the item from the foundation at position and add it the cell at position
                elif toPlace == 'cell':
                    self.cell[toPos] = self.foundation[fromPos].pop(len(self.foundation[fromPos]) - 1)
                # Add an empty value to the foundation to make it an empty foundation at the position
                self.foundation[fromPos] = [Card(0, 0)]

            # If the lenght of the foundation is more than 1
            else:
                # For cascade, remove the last item from foundation at position and append it the cascade
                if toPlace == 'cascade':
                    self.final_deck[toPos].append(self.foundation[fromPos].pop(len(self.foundation[fromPos]) - 1))
                # For cell, remove the last item from foundation at position and change the position at cell
                elif toPlace == 'cell':
                    self.cell[toPos] = self.foundation[fromPos].pop(len(self.foundation[fromPos]) - 1)

        elif fromPlace == 'cell':
            if toPlace == 'foundation':
                # If the foundation at position is empty
                if len(self.foundation[toPos]) == 1 and self.foundation[toPos][0].get_face() == 0:
                    # Pick the item from cell at position and add it to the first position of the foundation
                    self.foundation[toPos][0] = self.cell[fromPos]
                    # Make the cell empty
                    self.cell[fromPos] = Card(0, 0)
                else:
                    # Pick the item from cell and append it to the foundation at position
                    self.foundation[toPos].append(self.cell[fromPos])
                    # Make the cell empty
                    self.cell[fromPos] = Card(0, 0)
            if toPlace == 'cell':
                # Pick the value from cell from position and put it as destination
                self.cell[toPos] = self.cell[fromPos]
                # Make the cell empty
                self.cell[fromPos] = Card(0, 0)
            if toPlace == 'cascade':
                # Pick the item from cell and append it to the deck at position
                self.final_deck[toPos].append(self.cell[fromPos])
                # Make the cell empty
                self.cell[fromPos] = Card(0, 0)

    # The method is to return the face value and suit of the card from the place and the position
    # 0, 0 is returned if the position is empty
    def drawCard(self, place, position):

        # Check if the position is cascade, foundation or cell. Check if the lengh of the list at the mentioned
        # position is 0. If so return 0,0. Otherwise return the last item from the list
        if place == 'cascade':
            if len(self.final_deck[position]) == 0:
                return 0, 0
            else:
                return self.final_deck[position][len(self.final_deck[position]) - 1].get_face(), \
                       self.final_deck[position][len(self.final_deck[position]) - 1].get_suit()

        elif place == 'foundation':
            if len(self.foundation[position]) == 1 and self.foundation[position][0].get_face() == 0:
                return 0, 0
            else:
                return self.foundation[position][len(self.foundation[position]) - 1].get_face(), \
                       self.foundation[position][len(self.foundation[position]) - 1].get_suit()

        elif place == 'cell':
            if str(self.cell[position]) == '0:0':
                return 0, 0
            else:
                return self.cell[position].get_face(), self.cell[position].get_suit()

    # str method it to return the string which contains the output of the deck to be displayed to the user
    def __str__(self):

        # newString holds the value to be returned by adding all values needed
        newString = ''

        newString += '-----------------------------------------------------------------------------------------\n'
        newString += '----------------------------Welcome to Not FreeCell Game---------------------------------\n'
        newString += '-----------------------------------------------------------------------------------------\n'
        newString += '|Cells' + '\t\t\t\t|' + 'Foundation \n'

        # Adding the Cells
        for x in range(0, 4):
            newString += '[' + str(self.cell[x]) + ']' + '\t'

        # Adding the Foundation
        for x in range(0, 4):
            if len(self.foundation[x]) > 0:
                newString += '[' + str(self.foundation[x][len(self.foundation[x]) - 1]) + ']' + '\t'
            else:
                newString += '[ ]' + '\t\t'
        newString += '\n-----------------------------------------------------------------------------------------\n'
        newString += 'Cascade\n'

        # Copying the final_deck cascade
        cascade_print = copy.deepcopy(self.final_deck)

        max_size = 0
        # Finding the maximum size of the list cascase_print
        for count in range(len(cascade_print)):
            if len(cascade_print[count]) > max_size:
                max_size = len(cascade_print[count])

        # Adding a blank character to all the sublist to make it of same size
        for i in range(len(cascade_print)):
            cascade_print[i] += [''] * (max_size - len(cascade_print[i]))

        # Creating a zip using the list cascade_print
        cascade_zip = list(zip(*cascade_print))

        # Adding the cascade_zip to the newString to display the cascade list vertically
        for item in cascade_zip:
            for i in item:
                newString += str(i) + '\t'
            newString += '\n'

        newString += '-----------------------------------------------------------------------------------------\n'
        newString += '[ 1 ]\t[ 2 ]\t[ 3 ]\t[ 4 ]\t[ 5 ]\t[ 6 ]\t[ 7 ]\t[ 8 ]\t'

        return newString

    # This methos would check if the game has ended by checking if the foundation cells are filled with the cards
    def check_game(self):
        count = 0
        # Looping through the foundation cell and checking the size of each foundation
        if self.number_of_cards > 1:
            for i in range(0, 4):
                if len(self.foundation[i]) == self.number_of_cards:
                    count += 1
            print(count)

        else:
            # If the number of cards is one then checking the value of it in each foundation
            for i in range(0, 4):
                face, suit = self.drawCard('foundation', i)
                # If it is not an empty foundation cell
                if face != 0:
                    count += 1

        # If the count is equal to the number of suits then it means that the game has ended succesfully
        if count == self.number_of_suits:
            print("\n\n >> You have won the Game << \n\n")
            quit()


def main():
    pass


if __name__ == "__main__":
    main()
